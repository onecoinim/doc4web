## 开发插件和生成模板
插件（addon）可以让代码在应用间轻松共享

本向导将通过一个虚构的`ember-cli-xbutton`插件的开发过程来展开。

### 安装
一个插件可以像其他任何npm包一样安装：

`npm install --save-dev <package name>`

安装这个(虚构的)xbutton插件包：

`npm install --save-dev ember-cli-xbutton`

### 发现
Ember CLI将检查一个插件的存在，通过检测每个应用依赖，搜索他们的`package.json`文件，看在`keywords`部分是否有`ember-addon`关键字 (如下).

```javascript
  "keywords": [
    "ember-addon"
    ...
  ],
```

### 场景
Ember CLI插件API，当前支持下面的场景:

* 对在应用程序【译注1】的`Brocfile.js`文件中创建的`EmberApp`进行操作
* 添加预处理器到默认的注册表
* 提供一个自定义应用程序树与应用程序合并
* 提供定制的专用(服务器)中间件
* 添加自定义/额外的蓝图模板,通常为脚本生成应用程序/工程文件

### 插件命令行选项
Ember CLI有一个*addon*命令，带有下面的选项:

```bash
ember addon <addon-name> <options...>
  Creates a new folder and runs ember init in it.
  --dry-run (Default: false)
  --verbose (Default: false)
  --blueprint (Default: addon)
  --skip-npm (Default: false)
  --skip-bower (Default: false)
  --skip-git (Default: false)
```

注意：一个插件不会在已经存在的应用程序中被创建

### 创建插件
创建一个基本插件:

`ember addon <addon-name>`

运行该命令，就会产生下面这些文件：

```bash
ember addon my-xbutton
version x.y.zz
installing
  create .bowerrc
  create .editorconfig
  create tests/dummy/.jshintrc
  create .travis.yml
  create Brocfile.js
  create README.md

  create tests/dummy/app/app.js
  ... more test files

  create bower.json
  create .gitignore
  create package.json  

  ...
  create vendor/.gitkeep
  create addon/.gitkeep
  create app/.gitkeep
  create index.js

Installing packages for tooling via npm
Installed browser packages via Bower. 
```

### 插件约定
插件基础是基于“约定优于配置”的，与*Ember*哲学一致。建议您遵循这些约定,让自己更容易，让别人更好的理解你的代码。同样适用于插件的蓝图模板。

### 插件工程结构
创建插件项目遵循这些结构约定:

* `app/` - 合并到应用程序的命名空间。
* `addon/` - 插件的命名空间部分。
* `blueprints/` - 包含插件所有蓝图模板,每一个存放在一个独立的文件夹。
* `tests/` - 测试文件夹，包括一个"dummy"测试应用和验收测试助手。
* `vendor/` -第三方特定文件，比如stylesheets, fonts, 外部包等等。 
* `Brocfile.js` - 编译配置。
* `package.json` - Node元数据，依赖库等。
* `index.js` - 主要Node入口点(遵从npm约定)。

### Package.json
产生的插件的`package.json`文件，像这样:

```javascript
{
  "name": "ember-cli-xbutton", // 插件名称
  "version": "0.0.1", // 插件版本
  "directories": {
    "doc": "doc",
    "test": "test"
  },
  "scripts": {
    "start": "ember server",
    "build": "ember build",
    "test": "ember test"
  },
  "repository": "https://github.com/repo-user/my-addon",
  "engines": {
    "node": ">= 0.10.0"
  },
  "keywords": [
    "ember-addon"
    // 添加更多关键字，便于分类插件
  ],
  "ember-addon": {
    // 插件配置属性
    "configPath": "tests/dummy/config"
  },
  "author": "", // 你的名字
  "license": "MIT", // 协议
  "devDependencies": {
    "body-parser": "^1.2.0",
    ... // 在这里添加专门的依赖库!
}
```

让我们添加一些元数据来更好地分类该插件:

```javascript
  "keywords": [
    "ember-addon",
    "xbutton",
    "button"
  ],
```

### 插件入口节点
插件将利用npm约定，并寻找一个`index.js` 作为入口点，除非通过`package.json`文件的`"main"`属性指定另一个入口点。建议你使用`index.js`作为插件入口点。

产生的`index.js`文件是一个简单的js对象(POJO) ，你可以定制和扩展，像这样：

```javascript
// index.js
module.exports = {
  name: 'my-addon'
};
```

### 管理插件依赖
安装客户端依赖要通过'Bower'。这里我们安装一个虚构的bower依赖`xbutton`:

```
bower install --save-dev xbutton
```

添加bower组件到开发依赖

```javascript
// bower.js
{
  "name": "ember-xbutton",
  "dependencies": {
    // ...
  },
  "devDependencies": {
    "xbutton":  "^1.4.0"
  }
```

### 插件的Brocfile

通常你可以空着`Brocfile.js`文件，不用管它。只有需要定制插件的合并树时才去处理它。理解如何使用[Brocfile API](https://www.npmjs.org/package/broccoli).

### 组件
为了允许应用程序不用手动导入语句而使用插件组件,把组件放在`app/components`目录下。

```javascript
// app/components/xbutton.js
 
import Ember from 'ember';
import XButton from 'ember-xbutton/components/xbutton';
 
export default XButton;
```

代码从插件路径导入组件，再导出。这个设置允许其他代码通过扩展该组件修改它，同时使组件在应用程序命名空间中可用。

插件的实际代码放在`addon/components/xbutton.js`

```javascript
import Ember from 'ember';

export default Ember.Component.extend({
  tagName: 'button',

  setupXbutton: function() {
    // ...
  }.on('didInsertElement'),

  teardownXbutton: function() {
    this.get('xbutton').destroy();
  }.on('willDestroyElement'),
});
```

### 蓝图模板
为创建蓝图模板, 添加一个文件 `blueprints/xbutton/index.js`. 这遵循的是通常的Ember蓝图模板的命名约定。

确保依赖文件导入到应用程序。使用`included`钩子以正确的顺序导入文件。

```javascript
module.exports = {
  name: 'ember-cli-xbutton',
 
  included: function(app) {
    this._super.included(app);

    app.import('bower_components/unbutton/dist/unbutton.js');
    app.import('bower_components/xbutton/dist/js/xbutton.js');
    app.import('bower_components/xbutton/dist/css/xbutton.css');
  }
};
```

在这个例子文件里, `included` 钩子被使用。 这个钩子被`EmberApp` 构造函数调用，并且让该应用把它作为`app`调用，
当应用的`Brocfile.js` 被Ember CLI调用去build/serve的时候。插件的`included`函数被调用传递`EmberApp`实例.

### 高级定制
一般来说,如果你想超越定制或想要/需要更高级的控制，以下是`index.js`里一些插件对象的可用钩子(键)。所有的钩子期望函数的值。所有的钩子都希望把一个函数作为值。

```javascript
includedCommands: function() {}
blueprintsPath: // return path as String
postBuild: 
treeFor: 
included: 
postprocessTree: 
serverMiddleware: 
```

一个高级定制的例子可在[这里](https://github.com/poetic/ember-cli-cordova/blob/master/index.js)找到，或者服务器中间件 [这里](https://github.com/rwjblue/ember-cli-inject-live-reload/blob/master/index.js)

### 测试插件
插件工程包含一个`/tests` 文件夹，该文件夹包含运行和设置插件测试的基本文件。`/tests` 文件夹有下面的结构:

- `/dummy`
- `/helpers`
- `/unit`
- `index.html`
- `test_helper.js`

`/dummy` 文件夹包含一个基本的dummy应用，用于测试插件。 

`/helpers` 文件夹包含各类*qunit*助手，包括为了保持测试简洁你自己定义的。

`/unit` 文件夹包含你的单元测试，用以测试你的插件用于各种可用场景。这些测试也可以是完整的集成测试,测试被托管在虚拟应用程序中的插件。

`test_helper.js` 是应该在任何测试文件中引用的主要帮助文件，它导入了`resolver`助手，可以在`/helpers`文件夹中找到，用于解析`dummy`中的页面。

`index.html`包含浏览器中加载的测试页面，以显示运行单元测试的结果。

### 验收测试
下面是一个简单的*QUnit*验收测试的例子，放在`tests/unit/components`文件夹之下。

```javascript
// tests/unit/components/button-test.js

import { test, moduleForComponent } from 'ember-qunit';
import startApp from '../../helpers/start-app';
import Ember from 'ember';

var App;

moduleForComponent('xbutton', 'XButtonComponent', {
  setup: function() {
    App = startApp();
  },
  teardown: function() {
    Ember.run(App, 'destroy');
  }
});

test('is a button tag', function() {
  equal('BUTTON', this.$().prop('tagName'));

  this.subject().teardownXButton();
});

// more tests follow...
```

对于如何运行和设置测试，看 [[Ember CLI Testing]] 部分。

### 创建蓝图模板
蓝图模板是一些具有可选安装逻辑的模板文件。它用于根据一些参数和选项脚手架(生成)特定应用程序文件。
更多细节请看[[generators-and-blueprints]])。一个插件可以有一个或多个蓝图模板。

给你的插件创建一个*blueprint*:

`ember addon <blueprint-name> --blueprint`

按照惯例，插件的主要蓝图模板应该具有与插件相同的名称:

`ember addon <addon-name> --blueprint`

在我们的例子中:

`ember addon xbutton --blueprint`

这将为插件产生一个文件夹 `blueprints/xbutton`，在这里你可以定义蓝图模板的逻辑和模板文件。您可以为一个插件定义多个蓝图模板。
最后加载蓝图赢得对覆盖现有(同名)蓝图的灰烬或其他插件(根据包装加载顺序。)
The last loaded blueprint wins with respect to overriding existing (same name) blueprints that come with Ember or other addons (according to package load order.)

### 蓝图模板约定
Blueprints are expected to be located under the `blueprints` folder in the addon root, just like blueprints overrides in your project root.

If you have your blueprints in another folder in your addon, you need to tell ember-cli where to find them by specifying a `blueprintsPath` property for the addon (see *advanced customization* section below).

If you are familiar with *Yeoman* (or Rails) generators, blueprints follow very similar conventions and structure.

To dive deeper into blueprints design, please see the [Ember CLI blueprints](https://github.com/stefanpenner/ember-cli/tree/master/blueprints) where you get a feeling for the blueprints API. 

### 模板文件结构

```bash
blueprints/
  xbutton/
    index.js
    files/
      app/
        components/
          __name__/
  unbutton
    index.js
    files/
      config/
        __name__.js
```

Note that the special file or folder called `__name__` will create a file/folder at that location in your app with the `__name__` replaced by the first argument (name) you pass to the blueprint being generated.

`ember g xbutton my-button``

Will thus generate a folder `app/components/my-button` in the application where the blueprint generator is run.

### 开发时链接到插件
While you are developing and testing, you can run `npm link` from the root of your addon project. This will make your addon locally available by name.

Then run `npm link <addon-name>` in any hosting application project root to make a link to your addon in your `node_modules` folder. Any change in your addon will now directly take effect in any project that links to it this way (see [npm-tricks](http://www.devthought.com/2012/02/17/npm-tricks) for more details.

### 发布插件
Use *npm* and *git* to publish the addon like a normal npm package.

```bash
npm version 0.0.1
git push origin master
git push origin --tags
npm publish
```

See [npm-version](https://www.npmjs.org/doc/cli/npm-version.html) for details. 

These commands will:

- tag with the version number
- push the committed addon code to your git repo (origin branch)
- push the new tag to your git repo (origin branch)
- publish addon to the global npm repository.

### 安装和使用插件
In order to use the addon from you hosting application:

To install your addon from the [npm.org](https://www.npmjs.org/) repository:

`npm install ember-cli-<your-addon-name-here> --save-dev`.

For our *xbutton* sample addon:

`npm install ember-cli-xbutton --save-dev`.

Run the *xbutton* blueprint generator via:

`ember generate xbutton`

### 更新插件
You can update an addon the same way you update an Ember app by running `ember init` in your project root.

### 完整例子
For a good walkthrough of the (recent) development of a real world addon, take a look at: 
[Creating a DatePicker Ember CLI addon](http://edgycircle.com/blog/2014-creating-a-datepicker-ember-addon)

### 译注

1. the consuming application：是基于ember-cli等核心API开发的应用，英文通常就是这么称呼，也就是我们口头所说的应用程序，而非插件应用